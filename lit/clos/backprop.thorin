
.import mem;
.import core;
.import direct;

.let i32 = %Int 4294967296;
.let i8 = %Int 256;

.let M = %mem.M;
.let String = %mem.Ptr («⊤:.Nat; %Int 256», 0:.Nat);

.let ADD = %core.wrap.add (0, 4294967296);
.let MUL = %core.wrap.mul (0, 4294967296);
.let EQ = %core.icmp.e 4294967296;
.let LT = %core.icmp.sl 4294967296;

.cn printInt [M, i32, .Cn M];

.let PB_TYPE = .Cn M;

.let pb_lea = %mem.lea (⊤:.Nat, <⊤:.Nat; PB_TYPE>, 0);

.cn .extern main [mem: %mem.M, argc: i32, argv : %mem.Ptr («⊤:.Nat; %mem.Ptr («⊤:.Nat; %Int 256», 0:.Nat)», 0:.Nat), return : .Cn [%mem.M, i32]] = {
    .cn end [m: M] = {
        .cn end_print_cn [m: M] = { return (m, 0:i32) };
        printInt (m, 42:i32, end_print_cn)
    };

    .let (alloc_pb_mem, pb_ptr) = %mem.malloc (PB_TYPE, 0) (mem, 100);
    .let pb_arr = %core.bitcast ( %mem.Ptr («⊤:.Nat; PB_TYPE», 0), %mem.Ptr (PB_TYPE, 0)) pb_ptr;
    .let lea_pb = %mem.lea (⊤:.Nat, <⊤:.Nat; PB_TYPE>, 0) (pb_arr, 0:i32);
    .let store_pb_mem = %mem.store (PB_TYPE, 0) (alloc_pb_mem, lea_pb, end);

    .cn loop_head [m: M, i: i32] = {
        .cn exit [m: M] = {
            .let (backward_pass_mem, backward_pass) = %mem.load (PB_TYPE, 0) (m, lea_pb); // <- begin backward pass
            backward_pass backward_pass_mem
        };
        .cn body [m: M] = {
            .let (load_pb_mem, last_pb) = %mem.load (PB_TYPE, 0) (m, lea_pb);
            .cn K_print_cn [m: M] = {
                last_pb m
            };
            .cn K [m: M] = {
                printInt(m, i, K_print_cn)
            };
            .let store_pb_mem = %mem.store (PB_TYPE, 0) (load_pb_mem, lea_pb, K);  // << stack backward pass block
            .cn body_print_cn [m: M] = {
                loop_head (m, ADD (1:i32, i))
            };
            printInt(store_pb_mem, i, body_print_cn)
        };
        .let cond = LT (i, 5:i32);
        (body, exit)#cond m
    };

    loop_head (store_pb_mem, 0:i32)
};
